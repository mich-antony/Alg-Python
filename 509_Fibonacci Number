1. Recursive
Topdown

class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n-1) + self.fib(n-2)

S: O(n)
T: O(2^n)

----------------------------------------------------------------------------------
2. Recursive with Memorization
Topdown

class Solution:
    def fib(self, n: int) -> int:
        mem = {0:0, 1:1}

        def recfib(n: int) -> int: 
            if n in mem:
                return mem[n]

            mem[n] = recfib(n-1) + recfib(n-2)
            return mem[n]

        return recfib(n)

S: O(n)
T: O(n)

----------------------------------------------------------------------------------
3. Iterative
Bottom up (Tabulation)

class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n

        dp = [0, 1]

        for i in range(2, n+1):
            dp.append(dp[i-1] + dp[i-2])
        return dp[n]

S: O(n)
T: O(n)

----------------------------------------------------------------------------------
3. Iterative
Bottom up (Tabulation) - constant space

class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n

        prev = 0
        cur = 1

        for i in range(2, n+1):
            tmp = prev
            prev = cur
            cur= cur + tmp
        
        return cur


S: O(1)
T: O(n)
----------------------------------------------------------------------------------
